---
cate: 方法
date: 2026-01-07
tags:
  - output
banner: "40 - Obsidian/img/方法.jpg"
longform: false
---

> [!warning]
>
> 本文旨在帮助研究者从"有想法"到"可实现"，系统性地将研究问题转化为可执行的多主体模型设计方案。如果你已经完成了模型设计，正在考虑如何用代码实现它，请参看[[多主体模型实现心得|我的另一篇博客]]。

多主体建模（Agent-Based Modeling, ABM）的核心魅力在于：通过定义个体的简单行为规则，观察系统层面涌现出的复杂现象。然而，从一个模糊的研究问题到一个结构清晰、可执行的模型设计，往往是最令人困惑的阶段。本文将介绍一套经过实践检验的设计流程，帮助你系统性地完成这一跨越。

| 阶段                  | 核心问题       | 产出物         |
| ------------------- | ---------- | ----------- |
| [[#回答 ODD 文档的基本问题]] | 模型要回答什么问题？ | ODD 协议文档初稿  |
| [[#转化成模型语言]]        | 如何形式化描述？   | 主体/属性/行为描述表 |
| [[#模仿经典模型的涌现思路]]    | 涌现从何而来？    | 核心机制设计方案    |
| [[#思考模型验证的框架]]      | 如何证明模型可信？  | 验证策略与数据需求清单 |

## 回答 ODD 文档的基本问题

ODD（Overview, Design concepts, Details）协议是多主体建模领域最广泛接受的模型描述标准 [@grimm2006]。在设计阶段，与其把 ODD 当作"写完模型后补的文档"，不如把它当作**设计的脚手架**——逐条回答 ODD 的问题，能帮助你厘清思路、发现设计漏洞。

> [!tip] 先问问题，再写代码
>
> 许多建模新手急于动手写代码，结果发现核心机制没想清楚，反复推倒重来。花一天时间认真回答 ODD 问题，能节省一周的返工时间。

### Overview：模型的全局视角

这一部分需要你站在"上帝视角"描述整个模型系统。

**Purpose（目的）**：模型最核心的灵魂问题。你需要明确：这个模型是为了**解释**某个现象、**预测**某种趋势，还是**探索**某类可能性？模型的目标受众是谁——是同领域的学术同行，还是政策制定者？

> [!example] 以森林火灾模型为例
>
> **目的**：探索树木密度与火灾蔓延范围之间的非线性关系，识别是否存在"渗透阈值"（percolation threshold）。
> **受众**：对复杂系统感兴趣的研究者，用于教学演示临界现象。

**Entities, State Variables, and Scales（实体、状态变量与尺度）**：这是模型的"骨架"。你需要回答：

- 模型中有哪些类型的实体（主体、环境对象）？
- 每种实体有哪些属性？哪些是参数（不变），哪些是状态变量（会变化）？
- 有哪些外生驱动因素（exogenous factors）？
- 空间如何表示？时间步长和模拟总时长是多少？

### Design Concepts：设计理念

这一部分要求你说明模型"为什么这样设计"，是 ODD 中最能体现理论深度的部分。

**Process Overview and Scheduling（过程概览与调度）**：描述每个时间步中，各实体按什么顺序执行什么行为。一个清晰的调度流程图往往比文字描述更有效。

> [!note] 调度顺序的重要性
>
> 同样的行为规则，不同的执行顺序可能产生截然不同的涌现结果。例如，"先感知再行动"与"边感知边行动"在拥挤场景下会表现出完全不同的动力学特征。

**Theoretical and Empirical Background（理论与经验基础）**：这是连接你的模型与已有知识体系的桥梁。你需要说明：模型的核心假设基于什么理论？决策模型为什么选择这种形式？如果使用了经验数据，数据来源和聚合层级是什么？

**Individual Decision Making（个体决策）**：多主体模型的精髓在于个体决策的异质性。你需要详细说明：

- 决策的主体和客体分别是什么？
- 主体追求什么目标？是效用最大化、满意即止，还是基于规则的启发式？
- 主体如何响应内外部环境变化？
- 社会规范、文化价值观是否影响决策？
- 空间和时间因素如何进入决策过程？
- 不确定性如何体现在决策规则中？

**Learning（学习）**：如果你的模型涉及主体的适应性行为，需要说明：个体如何根据经验调整决策规则？是否存在集体学习或社会学习机制？

**Individual Sensing（个体感知）**：主体能"看到"什么决定了它能做出什么决策。关键问题包括：

- 主体能感知哪些环境变量和其他主体的状态？
- 感知过程是否有误差或噪声？
- 感知的空间范围有多大？
- 获取信息是否有成本？

**Individual Prediction（个体预测）**：如果主体需要对未来做出预期，你需要说明它们使用什么"内部模型"来预测，以及预测是否可能出错。

**Interaction（交互）**：主体之间如何相互作用是涌现的关键来源。需要考虑：

- 交互是直接的（面对面）还是间接的（通过环境媒介）？
- 交互依赖于什么条件（空间邻近、社会网络、随机配对）？
- 如果涉及通信，信息如何传递和表示？
- 如果存在协调网络，它是预设的还是涌现的？

**Collectives（集体）**：主体是否会形成群体、组织或联盟？这些集体结构是建模者预设的，还是在模拟中自发涌现的？

**Heterogeneity（异质性）**：主体之间有哪些差异？这些差异体现在属性上、行为规则上，还是两者兼有？

> [!warning] 异质性的取舍
>
> 异质性越丰富，模型越"真实"，但也越难分析和理解。建议从最小必要的异质性开始，逐步增加复杂度，每一步都验证新增异质性是否对涌现结果有实质影响。

**Stochasticity（随机性）**：哪些过程被建模为随机或部分随机的？随机性是为了表示真实的不确定性，还是为了简化未知的复杂机制？

**Observation（观测）**：你打算从模型中收集哪些数据？何时收集？这些数据如何帮助你回答研究问题？

## 转化成模型语言

回答完 ODD 问题后，下一步是将文字描述转化为结构化的模型语言。这一步的产出物是一套**可直接指导编程实现**的设计表格。

> [!tip] 表格化设计的好处
>
> 强迫自己把每个设计细节填入表格，能有效暴露含糊不清的地方。如果某一栏你填不出来，说明这部分设计还需要深入思考。

### 主体描述表

为模型中的每类实体建立一张"身份证"：

| 字段   | 说明                | 示例（农户主体）       |
| ---- | ----------------- | -------------- |
| 主体名称 | 主体类型的中文名称         | 农户             |
| 英文名称 | 用于代码中的类名          | `Farmer`       |
| 集合符号 | 用于数学公式中的集合表示      | $\mathcal{F}$  |
| 实例数量 | 初始化时的数量或数量范围      | $N_f = 100$    |
| 空间属性 | 是否有位置？位于什么类型的空间中？ | 位于 Grid Cell 上 |
| 生命周期 | 是否会出生/死亡？         | 模拟期间数量固定       |

### 属性描述表

每类主体的属性需要详细说明：

| 属性名  | 符号  | 外生/内生 | 数据类型  | 单位  | 取值范围       | 说明         | 参考文献         |
| ---- | --- | ----- | ----- | --- | ---------- | ---------- | ------------ |
| 年龄   | $a$ | 内生    | int   | 年   | $[18, 80]$ | 每时间步增加 1   | -            |
| 风险偏好 | $r$ | 外生    | float | -   | $[0, 1]$   | 初始化时从分布中抽取 | Smith et al. |
| 财富   | $w$ | 内生    | float | 元   | $[0, +∞)$  | 由收入和支出决定   | 模型内生         |

> [!note] 外生与内生的区分
>
> **外生属性**在模拟过程中不受模型内部机制影响（如固定的风险偏好参数），**内生属性**会随模拟演化（如财富水平）。这一区分对后续的敏感性分析和参数校准至关重要。

### 感知矩阵

用矩阵形式描述"谁能感知谁的什么"：

|            | Farmer  | Government | Environment |
| ---------- | ------- | ---------- | ----------- |
| Farmer     | 邻居的作物选择 | 政策信号       | 本地降水、土壤     |
| Government | 区域产量统计  | -          | 区域气候数据      |

这张表能帮你快速识别信息流动的结构，发现可能遗漏的交互关系。

### 行为描述表

每个行为规则需要形式化描述：

| 字段     | 说明             | 示例                                |
| ------ | -------------- | --------------------------------- |
| 主体类型   | 执行该行为的主体       | Farmer                            |
| 行为名称   | 行为的标识符         | `choose_crop`                     |
| 感知信息   | 行为依赖哪些感知输入     | 预期价格、邻居选择、土壤条件                    |
| 行为模型   | 决策的数学/逻辑表达     | $c^* = \arg\max_c U(c \mid r, w)$ |
| 自身属性变化 | 执行后改变自己的哪些属性   | 更新 `current_crop`                 |
| 他者属性变化 | 执行后改变其他主体的哪些属性 | 无                                 |
| 执行条件   | 何时触发该行为        | 每年播种季节开始时                         |
| 参考文献   | 行为模型的理论来源      | Expected Utility Theory           |

## 模仿经典模型的涌现思路

设计一个能产生有意义涌现的模型，并非易事。一个高效的学习路径是：**深入理解经典模型的涌现机制**，然后将这些机制迁移或组合到你的研究问题中。

> [!tip] 站在巨人的肩膀上
>
> 经典模型之所以"经典"，是因为它们用最简洁的规则捕捉到了某类涌现现象的本质。与其从零开始发明轮子，不如先问问自己：我的研究问题是否可以类比为某个经典涌现机制的变体？

### 不平等涌现：财富转移模型

**核心机制**：在简单的随机财富转移规则下（如每对相遇的主体随机转移一定财富），系统会自发演化出高度不平等的财富分布，即使初始时每个人的财富完全相等。

**适用场景**：资源分配、权力集中、"赢家通吃"现象。

**关键洞见**：不平等可能不需要"不公平的规则"来解释——对称的微观规则同样可以产生不对称的宏观结果。

### 空间分异：谢林隔离模型

**核心机制**：即使每个主体只有轻微的"同类偏好"（例如希望邻居中至少 30% 是同类），系统也会自发演化出高度隔离的空间格局。

**适用场景**：城市空间分异、意见极化、生态位分化。

**关键洞见**：个体层面的温和偏好可以在群体层面放大为极端结果。

### 资源竞争：糖域模型（Sugarscape）

**核心机制**：主体在空间中移动以寻找和消费资源，资源会以一定速率再生。引入视野、代谢率等异质性后，可以观察到人口动态、迁移模式、甚至原始贸易的涌现。

**适用场景**：生态系统动力学、人口迁移、资源型经济。

**关键洞见**：空间异质性 + 主体异质性 + 资源动态，三者的组合能产生丰富的涌现行为。

### 传播动力学：网络传播模型

**核心机制**：信息、疾病或行为通过网络中的连接在主体之间传播，传播概率取决于网络结构和个体特征。

**适用场景**：流行病传播、创新扩散、谣言传播、社会运动。

**关键洞见**：网络结构（如小世界、无标度）对传播动力学有决定性影响，少数"超级传播者"可能主导整个系统的行为。

> [!example] 机制组合示例
>
> 假设你研究的是"农业技术采纳的空间扩散"。你可以组合：
> - **谢林模型**的空间聚集机制（同类农户倾向于聚集）
> - **网络传播模型**的扩散机制（技术通过社会网络传播）
> - **糖域模型**的资源竞争逻辑（采纳新技术需要资本投入）
>
> 通过这种组合，你的模型就有了理论根基，而不是凭空构造。

## 思考模型验证的框架

一个设计精良但未经验证的模型，其科学价值是存疑的。在设计阶段就考虑验证策略，能帮助你做出更明智的设计取舍。

> [!warning] 验证不是事后补救
>
> 许多建模项目的失败源于：模型设计时没考虑可验证性，导致完成后发现无法获取验证所需的数据，或者模型输出与可观测数据之间没有可比性。

### 校准、验证与确认的区分

这三个概念经常被混淆，但它们有明确的分工：

| 概念               | 问题             | 方法示例       |
| ---------------- | -------------- | ---------- |
| 校准（Calibration）  | 参数值应该是多少？      | 参数拟合、贝叶斯推断 |
| 验证（Verification） | 模型是否正确实现了设计意图？ | 单元测试、极端值检验 |
| 确认（Validation）   | 模型是否充分代表了真实系统？ | 模式匹配、样本外预测 |

### 层次化验证框架（HAV）

基于 [Guerrero 等人的综述](https://dl.acm.org/doi/10.1145/3769857)，我们可以采用层次化的验证策略，在三个层级上分别应用适当的验证方法：

**代理层（Agent Level）**：验证单个主体的行为是否符合预期。

- **微观经验校准**：用调查数据、实验数据校准个体决策参数
- **行为测试**：检验主体在边界条件下的行为是否合理
- **专家审查**：邀请领域专家评估行为规则的合理性

**模型层（Model Level）**：验证主体之间的交互是否产生预期的中间层涌现。

- **敏感性分析**：识别关键参数，理解参数-行为的映射关系
- **退化测试**：将模型简化为已知解析解的特例，检验一致性
- **对照实验**：系统性地开关某些机制，观察效果

**输出层（Output Level）**：验证模型产生的宏观模式是否与观测数据一致。

- **模式匹配**：定性比较模型输出与经验观察的模式相似性
- **统计对比**：定量比较模型输出分布与观测数据分布
- **样本外预测**：用部分数据校准，检验对剩余数据的预测能力

> [!tip] 数据可用性决定验证策略
>
> 不是所有验证方法都适用于所有情境。选择验证方法时，首先盘点你能获取什么数据：
> - 有丰富的个体层面数据 → 强化代理层验证
> - 只有聚合层面的统计数据 → 聚焦输出层验证
> - 几乎没有经验数据 → 依赖理论一致性检验和敏感性分析

### 设计阶段的验证清单

在完成模型设计之前，确保你能回答以下问题：

1. **可观测输出**：模型的哪些输出可以与现实世界的观测进行比较？
2. **数据来源**：验证所需的数据从哪里获取？是否已经存在，还是需要专门收集？
3. **成功标准**：什么样的验证结果能让你（和审稿人）相信模型是"足够好"的？
4. **失败预案**：如果验证失败，你计划如何修改模型？哪些设计决策是可以调整的？

---

> [!note] 从设计到实现
>
> 完成了本文描述的设计流程后，你应该拥有：一份 ODD 协议文档初稿、一套结构化的主体/属性/行为描述表、对核心涌现机制的清晰认识、以及初步的验证策略。下一步，请参考[[多主体模型实现心得]]，了解如何将这些设计转化为可执行的代码。
